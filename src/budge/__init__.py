from dataclasses import InitVar, dataclass, field
from datetime import date
from heapq import merge
from typing import Self

from dateutil.rrule import rrule
from stockholm import Money


@dataclass
class Transaction:
    """A single transaction record."""

    date: date
    amount: Money
    description: str
    parent: "RecurringTransaction | Transfer | None" = None

    def __lt__(self, other: Self):
        """Compare transactions based on their date for ordering."""
        return self.date < other.date


@dataclass
class RecurringTransaction:
    """
    A transaction that repeats on a schedule described by a
    `dateutil.rrule.rrule`.
    """

    rrule: rrule
    amount: Money
    description: str

    def __iter__(self):
        """
        Yield transactions generated by the recurring rule, each with the
        specified amount and description, and link them to this recurring
        transaction as their parent.
        """
        for next in self.rrule:
            yield Transaction(
                date=next.date(),
                amount=self.amount,
                description=self.description,
                parent=self,
            )


@dataclass
class Account:
    """
    A register of transactions and repeating transactions that can be used to
    calculate or forecast a balance for any point in time.
    """

    name: str
    transactions: list[Transaction] = field(default_factory=list)
    recurring_transactions: list[RecurringTransaction] = field(default_factory=list)

    def __iter__(self):
        """
        Iterate over all transactions in the account, including those generated
        by recurring transactions, ordered by date. This is useful for
        calculating or forecasting a balance for any point in time.
        """

        for transaction in merge(
            *self.recurring_transactions, sorted(self.transactions)
        ):
            yield transaction

    def transactions_range(
        self, start_date: date | None = None, end_date: date | None = None
    ):
        """Iterate over transactions in the account over the given range."""
        for transaction in self:
            if start_date and transaction.date < start_date:
                continue
            if end_date and transaction.date > end_date:
                break
            yield transaction

    def balance(self, as_of: date = date.today()) -> Money:
        """Calculate the account balance as of the given date."""
        return Money(
            sum(
                transaction.amount
                for transaction in self.transactions_range(end_date=as_of)
            )
        )


@dataclass(kw_only=True)
class Transfer(Transaction):
    """Record of a transfer between two accounts."""

    from_account: InitVar[Account]
    to_account: InitVar[Account]
    from_transaction: Transaction = field(init=False)
    to_transaction: Transaction = field(init=False)

    def __post_init__(self, from_account: Account, to_account: Account):
        """
        Create the from and to transactions, add them to the respective accounts,
        and set their parent to this transfer.
        """
        self.from_transaction = Transaction(self.date, -self.amount, self.description)
        self.to_transaction = Transaction(self.date, self.amount, self.description)

        self.from_transaction.parent = self.to_transaction.parent = self

        from_account.transactions.append(self.from_transaction)
        to_account.transactions.append(self.to_transaction)
